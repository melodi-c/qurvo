---
name: issue-planner
description: "Сканирует кодовую базу по произвольному промпту и создаёт атомарные GitHub issues (или эпики с sub-issues), готовые к выполнению issue-executor. Вызов: /issue-planner <что искать>"
disable-model-invocation: true
---

# Issue Planner — Сканер и Создатель GitHub Issues

**РОЛЬ**: Ты — оркестратор. Получаешь промпт, делегируешь исследование кода специализированному агенту, формируешь на основе его находок атомарные GitHub issues (или эпики с sub-issues) и создаёшь их в проекте.

---

## Шаг 1: Получить промпт

Аргументы при вызове — задача/область для сканирования.

Если аргументов нет — спроси:
> Что нужно проанализировать? Примеры:
> - `найди все UX проблемы в web`
> - `найди N+1 запросы в API`
> - `accessibility audit: aria-labels, семантика`
> - `найди устаревшие паттерны для рефакторинга`
> - `найди потенциальные security проблемы`

---

## Шаг 2: Изучить контекст

Прочитай CLAUDE.md в корне и в релевантных приложениях (на основе промпта).

Получи список уже открытых issues чтобы не дублировать:
```bash
gh issue list --state open --json number,title --limit 50
```

---

## Шаг 3: Исследовать кодовую базу через code-explorer

Запусти подагента `feature-dev:code-explorer` в **foreground** (дождись результата перед Шагом 4).

Промпт для подагента:

```
Проведи глубокий анализ кодовой базы по следующей задаче:

<ПРОМПТ ПОЛЬЗОВАТЕЛЯ>

Уже открытые issues (не дублировать):
<СПИСОК ИЗ gh issue list>

Верни структурированный отчёт:
1. Список конкретных проблем/задач с точными файлами и строками
2. Для каждой — краткое описание что именно не так и что нужно сделать
3. Оценка приоритета: P1 (баг/blocker) / P2 (важно) / P3 (улучшение)
4. Зависимости между задачами (если есть)
5. Если задачи образуют связную фичу (3+ компонентов/файлов) — предлагай эпик-группировку: опиши фичу целиком, перечисли входящие sub-задачи и критерии приёмки

Охвати все релевантные файлы — чем полнее сканирование, тем лучше.
```

Используй результат подагента как основу для Шага 4.

---

## Шаг 4: Сформировать черновики issues

### Правила:

- **Атомарность**: 1 issue = 1 конкретная задача, выполнимая независимо одним агентом
- **Конкретность**: указывай точные файлы и строки (`apps/web/src/foo.tsx:42`), что именно делать
- **Группировка мелочей**: несколько тривиальных связанных задач в одном модуле — объединяй в 1 issue (с пронумерованным списком подзадач внутри)
- **Эпики**: если 3+ тесно связанных issues образуют единую фичу — создавай эпик с sub-issues. Каждый sub-issue сохраняет атомарный формат `type(scope): ...`
- **Зависимости**: если issue B зависит от A — добавь в тело B `Depends on: #PLACEHOLDER-A`, заменишь на реальный номер при создании
- **Не дублируй**: если похожая задача уже есть в открытых issues — пропусти

### Формат обычного issue:

**Заголовок**: `type(scope): краткое описание`
- `type`: `fix` / `feat` / `refactor` / `perf` / `docs` / `test` / `chore`
- `scope`: `web` / `api` / `ingest` / `processor` / `db` / `clickhouse` / `sdk` / конкретный модуль

**Тело**:
```
## Описание

[Подробное описание. Конкретные файлы со строками. Что именно изменить.
Для сгруппированных задач — нумерованный список.]

## Зависимости
Depends on: #NUMBER   ← только при реальной зависимости

## Приоритет
P1 / P2 / P3
```

### Формат эпика:

**Заголовок**: `feat(scope): название фичи`

**Тело**:
```
## Что и зачем

[Описание фичи: что делаем, зачем нужно, какую проблему решает]

## Критерии приёмки

- [ ] критерий 1
- [ ] критерий 2
- [ ] критерий 3

## Sub-issues

Будут автоматически привязаны: #N, #M, ...

## Приоритет
P1 / P2 / P3
```

Приоритет:
- **P1** — критично (баг, security, блокирует работу)
- **P2** — важно (заметно ухудшает UX или перформанс)
- **P3** — улучшение (рефакторинг, мелкие недочёты)

**Labels** (из существующих в проекте):
`bug`, `enhancement`, `refactor`, `ux/ui`, `architecture`, `web`, `api`, `security`, `billing`, `ai`, `i18n`, `good first issue`, `epic`

---

## Шаг 4.5: Проверка атомарности через issue-decomposer

Для каждого сформированного issue (не эпика) оцени: затрагивает ли он 3+ несвязанных модуля или требует изменений в 2+ приложениях одновременно? Если да — запусти `issue-decomposer` в **foreground**:

```
ISSUE_NUMBER: (ещё не создан, передай 0)
ISSUE_TITLE: <заголовок>
ISSUE_BODY: <тело>
REPO_ROOT: <REPO_ROOT>
```

- Если вернул `"atomic": true` → оставь issue как есть
- Если вернул список `sub_issues` → замени исходный issue на эти sub-issues в черновиках. Если их 3+ — автоматически оформи как эпик (применяй правила Шага 4)

Запускай decomposer параллельно для всех подозрительно крупных issues.

---

## Шаг 5: Показать preview и получить подтверждение

Обычные issues отображаются как прежде:
```
── 1 ──────────────────────────────────────────
Заголовок: fix(web): ...
Labels:    web, ux/ui
Приоритет: P2
Файлы: apps/web/src/foo.tsx:42

Краткое описание...
```

Эпики отображаются в расширенном формате:
```
══ EPIC 1 ══════════════════════════════════
feat(web): Переработка онбординга
Labels:    web, epic
Приоритет: P2

Что/зачем: [краткое описание]
Критерии приёмки:
  ✦ критерий 1
  ✦ критерий 2

Sub-issues:
  ├─ 1. fix(web): Исправить шаг 1 онбординга
  ├─ 2. feat(web): Добавить прогресс-бар
  └─ 3. refactor(web): Вынести логику в хук
════════════════════════════════════════════
```

Завершить preview строкой:
```
────────────────────────────────────────────────
Создать N issues в GitHub? (да / нет / редактировать)
```

**Дождись ответа:**
- `нет` → остановись
- `редактировать` → обсуди правки, покажи обновлённый список
- `да` → Шаг 6

---

## Шаг 6: Создать issues в GitHub

Создавай **последовательно** (чтобы отслеживать реальные номера для зависимостей).

### Получить OWNER/REPO один раз:
```bash
gh repo view --json owner,name --jq '"\(.owner.login)/\(.name)"'
```

### Создание обычного issue:
```bash
gh issue create \
  --title "type(scope): описание" \
  --body "$(cat <<'BODY'
## Описание

...

## Приоритет
P2
BODY
)" \
  --label "web,ux/ui"
```

После создания каждого issue — сохрани его номер. Если следующий issue имел `Depends on: #PLACEHOLDER-X` — замени на реальный номер перед созданием.

### Создание эпика с sub-issues:

**Порядок:**
1. Создать каждый sub-issue → сохранить `SUB_NUMBER_N`
2. Создать эпик issue (в теле указать реальные `#SUB_NUMBER_N`) → сохранить `EPIC_NUMBER`
3. Для каждого sub-issue получить внутренний ID:
   ```bash
   gh api repos/OWNER/REPO/issues/SUB_NUMBER --jq '.id'
   ```
4. Привязать каждый sub-issue к эпику:
   ```bash
   gh api repos/OWNER/REPO/issues/EPIC_NUMBER/sub_issues \
     --method POST \
     -F sub_issue_id=INTERNAL_ID
   ```

**Важно:**
- Sub-issues создавай без лейбла `epic`
- Эпик создавай с лейблом `epic` (плюс лейбл scope, например `web`)
- Если sub-issue имел `Depends on: #PLACEHOLDER-X` — замени на реальный номер перед созданием
- `gh api .../sub_issues` требует **внутренний числовой ID** (не `#number`), его возвращает `gh api .../issues/NUMBER --jq '.id'`

---

## Шаг 7: Итоговый отчёт

```
=== Создано N issues ===

═ EPIC #60 — feat(web): Переработка онбординга   [web, epic] P2
  ↳ #61 — fix(web): Исправить шаг 1               [web]       P2
  ↳ #62 — feat(web): Добавить прогресс-бар         [web]       P2
  ↳ #63 — refactor(web): Вынести логику в хук      [web]       P3
✓ #64 — perf(api): ...  (обычный issue)            [api]       P2

Для выполнения запусти:
  /issue-executor --label web
  /issue-executor 61 62 63 64
```
