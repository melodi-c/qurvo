---
name: issue-planner
description: "Сканирует кодовую базу по произвольному промпту и создаёт атомарные GitHub issues (или эпики с sub-issues), готовые к выполнению issue-executor. Вызов: /issue-planner <что искать>"
disable-model-invocation: true
---

# Issue Planner — Сканер и Создатель GitHub Issues

**РОЛЬ**: Ты — оркестратор. Получаешь промпт, при необходимости делегируешь исследование кода специализированному агенту, формируешь атомарные GitHub issues (или эпики с sub-issues) и создаёшь их в проекте.

---

## Шаг 1: Получить промпт и определить режим

Аргументы при вызове — задача/область для сканирования.

Если аргументов нет — спроси:
> Что нужно проанализировать? Примеры:
> - `найди все UX проблемы в web`
> - `найди N+1 запросы в API`
> - `accessibility audit: aria-labels, семантика`
> - `найди устаревшие паттерны для рефакторинга`
> - `добавить фичу: экспорт данных в CSV`

### Автодетект режима

Определи режим по промпту пользователя:

**`bug-report`** — конкретный баг, который пользователь уже наблюдал/знает:
- описывает симптом: "кнопка не работает", "страница падает", "неправильно отображается", "ошибка при..."
- слова: "не работает", "сломан", "баг", "ошибка", "падает", "неправильно", "fix", "broken", "crash", "wrong", "incorrect"
- есть конкретный экран/компонент/действие

**`audit`** — нужно найти проблемы в кодовой базе (пользователь не знает где):
- "найди все...", "проведи аудит", "найди N+1", "найди утечки", "security audit", "найди проблемы", "проверь на..."

**`feature`** — нужно добавить или реализовать что-то новое:
- слова: "добавить", "реализовать", "сделать", "нужна возможность", "feat", "implement", "add", "create"
- или описание желаемого поведения без указания на поломку

Если неоднозначно — определи по контексту с reasoning. Объясни себе почему выбрал конкретный режим перед тем как продолжить.

---

## Шаг 2: Изучить контекст

Прочитай CLAUDE.md в корне и в релевантных приложениях (на основе промпта).

Получи список уже открытых issues чтобы не дублировать:
```bash
gh issue list --state open --json number,title --limit 50
```

Проверь открытые PR на предмет пересечений:
```bash
gh pr list --state open --json number,title,headRefName --limit 20
```
Если есть PR, затрагивающий ту же область — отметь это в preview (Шаг 5).

---

## Шаг 3: Исследовать кодовую базу

### Режим `bug-report` — облегчённое исследование

Запусти подагента (subagent_type: "Explore") в **foreground** с облегчённым промптом:

```
Быстрый анализ бага:

<ПРОМПТ ПОЛЬЗОВАТЕЛЯ>

Найди:
1. Файлы, вероятно связанные с багом (по ключевым словам из описания)
2. Вероятный root cause (если можешь определить)
3. affected_apps (какие приложения затронуты)

НЕ нужен полный аудит — только локализация бага.
Верни: affected_files, affected_apps, probable_root_cause (если нашёл).
```

Результат используй для заполнения `## Agent Context` в шаблоне issue (Шаг 4).

### Режим `audit` и `feature` — полное исследование

Запусти подагента (subagent_type: "Explore") в **foreground** (дождись результата перед Шагом 4).

Промпт зависит от режима:

### Режим `audit`:
```
Проведи анализ кодовой базы для поиска следующих проблем:

<ПРОМПТ ПОЛЬЗОВАТЕЛЯ>

Уже открытые issues (не дублировать):
<СПИСОК ИЗ gh issue list>

Сфокусируйся на:
1. Найди все места в коде где встречается описанная проблема (файлы, строки, функции)
2. Для каждого случая — определи root cause и что именно нужно изменить
3. Проверь есть ли существующие тесты которые должны были это покрыть
4. Оцени приоритет каждой находки: P1 (блокирует) / P2 (важно) / P3 (мелкий баг)
5. Сгруппируй находки по теме/модулю для объединения в issues

Верни конкретные файлы и строки, не общие описания.
```

### Режим `feature`:
```
Проведи анализ кодовой базы для планирования реализации следующей фичи:

<ПРОМПТ ПОЛЬЗОВАТЕЛЯ>

Уже открытые issues (не дублировать):
<СПИСОК ИЗ gh issue list>

Сфокусируйся на:
1. Изучи существующую архитектуру релевантных модулей (как устроено сейчас)
2. Определи какие файлы/модули нужно создать и какие расширить
3. Выяви зависимости между частями (что нужно сделать раньше)
4. Предложи разбивку на атомарные задачи (backend / frontend / DB / тесты)
5. Для каждой задачи — конкретные файлы и что именно изменить/добавить
6. Если задачи образуют единую фичу — предложи эпик с acceptance criteria

Верни план реализации с конкретными файлами, не абстрактные описания.
```

Используй результат подагента как основу для Шага 4.

---

## Шаг 4: Сформировать черновики issues

### Общие правила:

- **Атомарность**: 1 issue = 1 проблема или область изменений, выполнимая независимо одним агентом. Количество затронутых файлов НЕ определяет атомарность — несколько файлов в одной теме это нормально
- **Конкретность**: указывай точные файлы и строки (`apps/web/src/foo.tsx:42`), что именно делать
- **Группировка по теме (ОБЯЗАТЕЛЬНО для bug и refactor)**: если несколько изменений относятся к одной теме, фиче или компоненту — объединяй в 1 issue с чеклистом `- [ ] шаг`. Не создавай отдельные issues для каждого файла или каждой строки. Примеры групп: "все i18n-фиксы в модуле X", "все N+1 запросы в сервисе Y", "типизация параметров API в контроллере Z"
- **НЕ дроби**: если изменения P3/P2 и связаны одной причиной — это ОДИН issue, даже если затрагивает 5+ файлов
- **Эпики**: если 3+ тесно связанных issues образуют единую фичу — создавай эпик с sub-issues. Каждый sub-issue сохраняет атомарный формат `type(scope): ...`
- **Зависимости**: если issue B (preview #3) зависит от A (preview #1) — добавь в тело B `Depends on: #DRAFT-1`. При создании в Шаге 6 заменяй `#DRAFT-N` на реальный GitHub номер
- **Не дублируй**: если похожая задача уже есть в открытых issues — пропусти

### Формат issue зависит от режима:

**Режим `bug-report` — тело issue** (конкретный баг от пользователя, без code-explorer):
```
## Описание

[Что происходит — точная формулировка от пользователя.]

## Steps to Reproduce

1. [Шаг 1]
2. [Шаг 2]

**Ожидалось**: [что должно было произойти]
**Произошло**: [что произошло на самом деле]

(если воспроизведение неизвестно — пропусти секцию)

## Acceptance Criteria

- [ ] [Что должно работать корректно после фикса]

## Зависимости
Depends on: #NUMBER   ← только при реальной зависимости

## Приоритет
P1 / P2 / P3
```
Labels: `bug` + scope (`web`, `api`, etc.) + `size:xs/s/m/l`

**Agent Context** (добавляй во ВСЕ шаблоны после основного тела):
```
## Agent Context

- **starting_locus**: apps/api/src/events/events.service.ts  ← первый файл для solver
- **affected_apps**: apps/web, apps/api
- **affected_files**:
  - apps/api/src/events/events.service.ts:142-180 (modify processEvent)
  - apps/api/src/events/events.controller.ts:35 (add endpoint)
- **root_cause**: (для bug-report — из code-explorer; для остальных — опционально)
- **complexity**: xs / s / m / l
- **has_migrations**: true / false
- **verification**: pnpm --filter @qurvo/api exec vitest run --config vitest.integration.config.ts
- **boundaries**: Do NOT modify apps/web or packages/@qurvo/db  ← что solver НЕ должен трогать
```

Поля:
- **starting_locus** — файл, с которого solver должен начать чтение. Самый важный файл для понимания контекста
- **affected_files** — с указанием строк и что именно изменить (функция/метод, а не просто файл)
- **verification** — конкретная команда для проверки. Всегда из CLAUDE.md (vitest, tsc, build)
- **boundaries** — что solver НЕ должен менять. Предотвращает расползание scope

Эта секция **не для людей**, а для solver'а — он использует её для быстрого старта.

**Режим `audit` — тело issue** (найдено через code-explorer):
```
## Описание

[Что происходит и где. Если несколько мест — перечисли все.]

## Root Cause

[Почему происходит. Какой код виновен.]

## Что изменить

- [ ] `apps/web/src/foo.tsx:42` — [что именно]
- [ ] `apps/web/src/bar.tsx:17` — [что именно]
- [ ] ...

(если изменение одно — можно просто текстом без чеклиста)

## Acceptance Criteria

- [ ] [Как проверить что проблема исправлена — конкретный сценарий или тест]

## Зависимости
Depends on: #NUMBER   ← только при реальной зависимости

## Приоритет
P1 / P2 / P3
```
Labels: `bug` + scope (`web`, `api`, etc.) + `size:xs/s/m/l` + `has-migrations` (если затрагивает DB/CH)

**Режим `feature` — тело обычного issue:**
```
## Описание

[Что нужно реализовать. Конкретные файлы — что создать, что расширить.]

## Acceptance Criteria

- [ ] [Измеримый критерий 1 — что именно должно работать]
- [ ] [Измеримый критерий 2]

## Technical Notes

[Паттерны из CLAUDE.md, существующий код на который ориентироваться, подводные камни]

## Зависимости
Depends on: #NUMBER   ← только при реальной зависимости

## Приоритет
P1 / P2 / P3
```
Labels: `enhancement` + scope + `size:xs/s/m/l` + `has-migrations` (если затрагивает DB/CH)

**Формат эпика** (только для `feature` режима):

Заголовок: `feat(scope): название фичи`

```
## Что и зачем

[Описание фичи: что делаем, зачем нужно, какую проблему решает]

## Критерии приёмки

- [ ] критерий 1
- [ ] критерий 2
- [ ] критерий 3

## Sub-issues

Будут автоматически привязаны: #N, #M, ...

## Приоритет
P1 / P2 / P3
```
Labels: `epic` + scope

### Приоритет:
- **P1** — критично (баг, security, блокирует работу)
- **P2** — важно (заметно ухудшает UX или перформанс)
- **P3** — улучшение (рефакторинг, мелкие недочёты)

### Оценка размера (`size:*`) — обязательно для каждого issue:

Оценивай по **объёму и сложности изменений**, а не только по числу файлов:

- **`size:xs`** — тривиальное изменение: опечатка, однострочный фикс, добавить одно поле. ~10 строк кода
- **`size:s`** — локальное изменение: добавить endpoint, исправить компонент, написать тесты для существующего кода. ~50 строк кода, 1-3 файла
- **`size:m`** — умеренное изменение: новый модуль, новая страница, набор связанных изменений. ~150 строк кода, требует понимания нескольких модулей
- **`size:l`** — крупное изменение: архитектурные изменения, новая фича с backend+frontend+DB. ~300+ строк, затрагивает несколько приложений или новый app

Сложность повышается если: требуются миграции, новые паттерны (не по аналогии), изменения в shared-пакетах, или затрагивает auth/billing.

### Лейбл `has-migrations`:
Добавляй к issue если он явно затрагивает:
- `packages/@qurvo/db` — Drizzle-схему PostgreSQL
- `packages/@qurvo/clickhouse` — ClickHouse миграции

Это сигнал для executor не параллелизировать такие issues с другими DB-issues.

**Labels** (из существующих в проекте):

Тип: `bug`, `enhancement`, `refactor`, `epic`, `good first issue`
Scope: `web`, `api`, `ingest`, `processor`, `cohort-worker`, `billing-worker`, `security`, `billing`, `ai`, `i18n`, `ux/ui`, `architecture`
Size: `size:xs`, `size:s`, `size:m`, `size:l`
Meta: `has-migrations`

---

## Шаг 4.5: Проверка атомарности через issue-decomposer

**Для режимов `feature` и `audit`** (не для `bug-report` — фиксы багов объединены в 1 issue с чеклистом).

Для каждого сформированного issue (не эпика) в режиме `feature` или `audit` оцени: затрагивает ли он 3+ несвязанных модуля или требует изменений в 2+ приложениях одновременно? Если да — запусти `issue-decomposer` в **foreground**:

```
subagent_type: "issue-decomposer"
model: sonnet
run_in_background: false
prompt: |
  REPO_ROOT: $CLAUDE_PROJECT_DIR
  ISSUE_NUMBER: 0
  ISSUE_TITLE: <заголовок>
  ISSUE_BODY: <тело>
  RESULT_FILE: /tmp/claude-results/decomposer-draft-<порядковый номер>.json
```

- Если вернул `"atomic": true` → оставь issue как есть
- Если вернул список `sub_issues` → замени исходный issue на эти sub-issues в черновиках:
  - Транслируй `depends_on` из decomposer (индекс в массиве sub_issues) в `Depends on: #DRAFT-N`, где N — порядковый номер sub-issue в preview. Пример: decomposer вернул `depends_on: 0` → первый sub-issue стал preview #2 → `Depends on: #DRAFT-2`
  - При создании в Шаге 6 заменяй `#DRAFT-N` на реальный GitHub `#NUMBER`
  - Если sub-issues 3+ — автоматически оформи как эпик (применяй правила Шага 4)
  - Перенеси labels из каждого sub-issue в черновики

Запускай decomposer параллельно для всех подозрительно крупных issues.

---

## Шаг 5: Показать preview и получить подтверждение

Обычные issues отображаются как прежде:
```
── 1 ──────────────────────────────────────────
Заголовок: fix(web): ...
Labels:    web, ux/ui
Приоритет: P2
Файлы: apps/web/src/foo.tsx:42

Краткое описание...
```

Эпики отображаются в расширенном формате:
```
══ EPIC 1 ══════════════════════════════════
feat(web): Переработка онбординга
Labels:    web, epic
Приоритет: P2

Что/зачем: [краткое описание]
Критерии приёмки:
  ✦ критерий 1
  ✦ критерий 2

Sub-issues:
  ├─ 1. fix(web): Исправить шаг 1 онбординга
  ├─ 2. feat(web): Добавить прогресс-бар
  └─ 3. refactor(web): Вынести логику в хук
════════════════════════════════════════════
```

Завершить preview строкой:
```
────────────────────────────────────────────────
Создать N issues в GitHub? (да / нет / да 1,3,5 / редактировать)
```

**Дождись ответа:**
- `нет` → остановись
- `редактировать` → обсуди правки, покажи обновлённый список
- `да` → создать все issues (Шаг 6)
- `да 1,3,5` → создать только указанные issues (по номерам из preview). Пересчитай зависимости: если issue с `Depends on` ссылается на исключённый — убери зависимость

---

### Шаг 5.5: Проверка лейблов

Перед созданием issues убедись, что все нужные лейблы существуют:

```bash
bash "$CLAUDE_PROJECT_DIR/.claude/scripts/setup-labels.sh"
```

Если скрипт недоступен — создай лейблы вручную:
```bash
for label in bug enhancement refactor web api "ux/ui" "size:xs" "size:s" "size:m" "size:l" epic "has-migrations"; do
  gh label create "$label" --color "ededed" 2>/dev/null || true
done
```

---

## Шаг 6: Создать issues в GitHub

Создавай **последовательно** (чтобы отслеживать реальные номера для зависимостей).

### Восстановление при ошибке

Перед созданием первого issue выведи пользователю маппинг-таблицу:
```
Создание issues... (DRAFT-N → GitHub #)
```
После каждого успешного создания — добавляй строку:
```
DRAFT-1 → #812 ✓
DRAFT-2 → #813 ✓
DRAFT-3 → ✗ (ошибка: rate limit)
```
При ошибке — сообщи пользователю, какие issues уже созданы и какие остались. Предложи продолжить (`да` → создать оставшиеся, `нет` → остановиться).

### Получить OWNER/REPO один раз:
```bash
gh repo view --json owner,name --jq '"\(.owner.login)/\(.name)"'
```

### Создание обычного issue:

**Важно**: Экранируй спецсимволы в `--title`:
- Backticks `` ` `` → `\``
- `$` → `\$`
- Используй single-quoted heredoc для body (уже используется `<<'BODY'`)

```bash
gh issue create \
  --title "type(scope): описание" \
  --body "$(cat <<'BODY'
## Описание

...

## Приоритет
P2
BODY
)" \
  --label "web" --label "ux/ui"
```

После создания каждого issue — сохрани маппинг: `DRAFT-N → реальный #NUMBER`. Если следующий issue содержит `Depends on: #DRAFT-N` — замени на реальный номер перед созданием.

### Создание эпика с sub-issues:

**Порядок:**
1. Создать каждый sub-issue → сохранить `SUB_NUMBER_N`
2. Создать эпик issue (в теле указать реальные `#SUB_NUMBER_N`) → сохранить `EPIC_NUMBER`
3. Для каждого sub-issue получить внутренний ID:
   ```bash
   gh api repos/OWNER/REPO/issues/SUB_NUMBER --jq '.id'
   ```
4. Привязать каждый sub-issue к эпику:
   ```bash
   gh api repos/{owner}/{repo}/issues/$EPIC_NUMBER/sub_issues \
     --method POST \
     --field sub_issue_id="$SUB_ISSUE_ID"
   ```

**Важно:**
- Sub-issues создавай без лейбла `epic`
- Эпик создавай с лейблом `epic` (плюс лейбл scope, например `web`)
- Если sub-issue содержит `Depends on: #DRAFT-N` — замени на реальный номер перед созданием
- `gh api .../sub_issues` требует **внутренний числовой ID** (не `#number`), его возвращает `gh api .../issues/NUMBER --jq '.id'`

---

## Шаг 7: Итоговый отчёт и автоматическая валидация

```
=== Создано N issues ===

═ EPIC #60 — feat(web): Переработка онбординга   [web, epic] P2
  ↳ #61 — fix(web): Исправить шаг 1               [web]       P2
  ↳ #62 — feat(web): Добавить прогресс-бар         [web]       P2
  ↳ #63 — refactor(web): Вынести логику в хук      [web]       P3
✓ #64 — perf(api): ...  (обычный issue)            [api]       P2

Если среди созданных issues есть dependency chain (`Depends on: #N`):
  Для выполнения запусти с номерами всех issues:
    /issue-executor <номера через пробел>
Иначе:
  Для выполнения запусти:
    /issue-executor --label ready
```

Issues создаются по строгому шаблону с acceptance criteria — отдельная валидация не нужна. Executor автоматически запустит `issue-validator` перед выполнением для issues без лейбла `ready`.
