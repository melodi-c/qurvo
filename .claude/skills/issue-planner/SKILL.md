---
name: issue-planner
description: "Сканирует кодовую базу по произвольному промпту и создаёт атомарные GitHub issues (или эпики с sub-issues), готовые к выполнению issue-executor. Вызов: /issue-planner <что искать>"
disable-model-invocation: true
---

# Issue Planner — Сканер и Создатель GitHub Issues

**РОЛЬ**: Ты — оркестратор. Получаешь промпт, делегируешь исследование кода специализированному агенту, формируешь на основе его находок атомарные GitHub issues (или эпики с sub-issues) и создаёшь их в проекте.

---

## Шаг 1: Получить промпт и определить режим

Аргументы при вызове — задача/область для сканирования.

Если аргументов нет — спроси:
> Что нужно проанализировать? Примеры:
> - `найди все UX проблемы в web`
> - `найди N+1 запросы в API`
> - `accessibility audit: aria-labels, семантика`
> - `найди устаревшие паттерны для рефакторинга`
> - `добавить фичу: экспорт данных в CSV`

### Автодетект режима

Определи режим по промпту пользователя:

**`bug`** — если промпт описывает что-то сломанное или неправильное:
- слова: "не работает", "сломан", "баг", "ошибка", "падает", "неправильно", "fix", "broken", "crash", "wrong", "incorrect"
- или запрос на аудит/поиск проблем: "найди N+1", "найди утечки", "security audit", "найди проблемы"

**`feature`** — если промпт описывает что нужно добавить или реализовать:
- слова: "добавить", "реализовать", "сделать", "нужна возможность", "feat", "implement", "add", "create"
- или описание желаемого поведения без указания на поломку

Если неоднозначно — выбери `bug`.

---

## Шаг 2: Изучить контекст

Прочитай CLAUDE.md в корне и в релевантных приложениях (на основе промпта).

Получи список уже открытых issues чтобы не дублировать:
```bash
gh issue list --state open --json number,title --limit 50
```

---

## Шаг 3: Исследовать кодовую базу через code-explorer

Запусти подагента `feature-dev:code-explorer` в **foreground** (дождись результата перед Шагом 4).

Промпт зависит от режима:

### Режим `bug`:
```
Проведи анализ кодовой базы для поиска root cause следующей проблемы:

<ПРОМПТ ПОЛЬЗОВАТЕЛЯ>

Уже открытые issues (не дублировать):
<СПИСОК ИЗ gh issue list>

Сфокусируйся на:
1. Найди точное место в коде где возникает проблема (файлы, строки, функции)
2. Определи root cause — почему это происходит
3. Найди все связанные места которые нужно изменить для фикса
4. Проверь есть ли существующие тесты которые должны были это покрыть
5. Оцени приоритет: P1 (блокирует) / P2 (важно) / P3 (мелкий баг)
6. Если проблема встречается в нескольких местах — перечисли все

Верни конкретные файлы и строки, не общие описания.
```

### Режим `feature`:
```
Проведи анализ кодовой базы для планирования реализации следующей фичи:

<ПРОМПТ ПОЛЬЗОВАТЕЛЯ>

Уже открытые issues (не дублировать):
<СПИСОК ИЗ gh issue list>

Сфокусируйся на:
1. Изучи существующую архитектуру релевантных модулей (как устроено сейчас)
2. Определи какие файлы/модули нужно создать и какие расширить
3. Выяви зависимости между частями (что нужно сделать раньше)
4. Предложи разбивку на атомарные задачи (backend / frontend / DB / тесты)
5. Для каждой задачи — конкретные файлы и что именно изменить/добавить
6. Если задачи образуют единую фичу — предложи эпик с acceptance criteria

Верни план реализации с конкретными файлами, не абстрактные описания.
```

Используй результат подагента как основу для Шага 4.

---

## Шаг 4: Сформировать черновики issues

### Общие правила:

- **Атомарность**: 1 issue = 1 проблема или область изменений, выполнимая независимо одним агентом. Количество затронутых файлов НЕ определяет атомарность — несколько файлов в одной теме это нормально
- **Конкретность**: указывай точные файлы и строки (`apps/web/src/foo.tsx:42`), что именно делать
- **Группировка по теме (ОБЯЗАТЕЛЬНО для bug и refactor)**: если несколько изменений относятся к одной теме, фиче или компоненту — объединяй в 1 issue с чеклистом `- [ ] шаг`. Не создавай отдельные issues для каждого файла или каждой строки. Примеры групп: "все i18n-фиксы в модуле X", "все N+1 запросы в сервисе Y", "типизация параметров API в контроллере Z"
- **НЕ дроби**: если изменения P3/P2 и связаны одной причиной — это ОДИН issue, даже если затрагивает 5+ файлов
- **Эпики**: если 3+ тесно связанных issues образуют единую фичу — создавай эпик с sub-issues. Каждый sub-issue сохраняет атомарный формат `type(scope): ...`
- **Зависимости**: если issue B зависит от A — добавь в тело B `Depends on: #PLACEHOLDER-A`, заменишь на реальный номер при создании
- **Не дублируй**: если похожая задача уже есть в открытых issues — пропусти

### Формат issue зависит от режима:

**Режим `bug` — тело issue:**
```
## Описание

[Что происходит и где. Если несколько мест — перечисли все.]

## Root Cause

[Почему происходит. Какой код виновен.]

## Что изменить

- [ ] `apps/web/src/foo.tsx:42` — [что именно]
- [ ] `apps/web/src/bar.tsx:17` — [что именно]
- [ ] ...

(если изменение одно — можно просто текстом без чеклиста)

## Зависимости
Depends on: #NUMBER   ← только при реальной зависимости

## Приоритет
P1 / P2 / P3
```
Labels: всегда добавляй `bug` + scope (`web`, `api`, etc.)

**Режим `feature` — тело обычного issue:**
```
## Описание

[Что нужно реализовать. Конкретные файлы — что создать, что расширить.]

## Зависимости
Depends on: #NUMBER   ← только при реальной зависимости

## Приоритет
P1 / P2 / P3
```
Labels: `enhancement` + scope

**Формат эпика** (только для `feature` режима):

Заголовок: `feat(scope): название фичи`

```
## Что и зачем

[Описание фичи: что делаем, зачем нужно, какую проблему решает]

## Критерии приёмки

- [ ] критерий 1
- [ ] критерий 2
- [ ] критерий 3

## Sub-issues

Будут автоматически привязаны: #N, #M, ...

## Приоритет
P1 / P2 / P3
```
Labels: `epic` + scope

### Приоритет:
- **P1** — критично (баг, security, блокирует работу)
- **P2** — важно (заметно ухудшает UX или перформанс)
- **P3** — улучшение (рефакторинг, мелкие недочёты)

**Labels** (из существующих в проекте):
`bug`, `enhancement`, `refactor`, `ux/ui`, `architecture`, `web`, `api`, `security`, `billing`, `ai`, `i18n`, `good first issue`, `epic`

---

## Шаг 4.5: Проверка атомарности через issue-decomposer

**Только для режима `feature`.** В режиме `bug` decomposer не запускать — мелкие фиксы специально объединены в 1 issue с чеклистом.

Для каждого сформированного issue (не эпика) в режиме `feature` оцени: затрагивает ли он 3+ несвязанных модуля или требует изменений в 2+ приложениях одновременно? Если да — запусти `issue-decomposer` в **foreground**:

```
ISSUE_NUMBER: (ещё не создан, передай 0)
ISSUE_TITLE: <заголовок>
ISSUE_BODY: <тело>
REPO_ROOT: <REPO_ROOT>
```

- Если вернул `"atomic": true` → оставь issue как есть
- Если вернул список `sub_issues` → замени исходный issue на эти sub-issues в черновиках. Если их 3+ — автоматически оформи как эпик (применяй правила Шага 4)

Запускай decomposer параллельно для всех подозрительно крупных issues.

---

## Шаг 5: Показать preview и получить подтверждение

Обычные issues отображаются как прежде:
```
── 1 ──────────────────────────────────────────
Заголовок: fix(web): ...
Labels:    web, ux/ui
Приоритет: P2
Файлы: apps/web/src/foo.tsx:42

Краткое описание...
```

Эпики отображаются в расширенном формате:
```
══ EPIC 1 ══════════════════════════════════
feat(web): Переработка онбординга
Labels:    web, epic
Приоритет: P2

Что/зачем: [краткое описание]
Критерии приёмки:
  ✦ критерий 1
  ✦ критерий 2

Sub-issues:
  ├─ 1. fix(web): Исправить шаг 1 онбординга
  ├─ 2. feat(web): Добавить прогресс-бар
  └─ 3. refactor(web): Вынести логику в хук
════════════════════════════════════════════
```

Завершить preview строкой:
```
────────────────────────────────────────────────
Создать N issues в GitHub? (да / нет / редактировать)
```

**Дождись ответа:**
- `нет` → остановись
- `редактировать` → обсуди правки, покажи обновлённый список
- `да` → Шаг 6

---

## Шаг 6: Создать issues в GitHub

Создавай **последовательно** (чтобы отслеживать реальные номера для зависимостей).

### Получить OWNER/REPO один раз:
```bash
gh repo view --json owner,name --jq '"\(.owner.login)/\(.name)"'
```

### Создание обычного issue:
```bash
gh issue create \
  --title "type(scope): описание" \
  --body "$(cat <<'BODY'
## Описание

...

## Приоритет
P2
BODY
)" \
  --label "web,ux/ui"
```

После создания каждого issue — сохрани его номер. Если следующий issue имел `Depends on: #PLACEHOLDER-X` — замени на реальный номер перед созданием.

### Создание эпика с sub-issues:

**Порядок:**
1. Создать каждый sub-issue → сохранить `SUB_NUMBER_N`
2. Создать эпик issue (в теле указать реальные `#SUB_NUMBER_N`) → сохранить `EPIC_NUMBER`
3. Для каждого sub-issue получить внутренний ID:
   ```bash
   gh api repos/OWNER/REPO/issues/SUB_NUMBER --jq '.id'
   ```
4. Привязать каждый sub-issue к эпику:
   ```bash
   gh api repos/OWNER/REPO/issues/EPIC_NUMBER/sub_issues \
     --method POST \
     -F sub_issue_id=INTERNAL_ID
   ```

**Важно:**
- Sub-issues создавай без лейбла `epic`
- Эпик создавай с лейблом `epic` (плюс лейбл scope, например `web`)
- Если sub-issue имел `Depends on: #PLACEHOLDER-X` — замени на реальный номер перед созданием
- `gh api .../sub_issues` требует **внутренний числовой ID** (не `#number`), его возвращает `gh api .../issues/NUMBER --jq '.id'`

---

## Шаг 7: Итоговый отчёт

```
=== Создано N issues ===

═ EPIC #60 — feat(web): Переработка онбординга   [web, epic] P2
  ↳ #61 — fix(web): Исправить шаг 1               [web]       P2
  ↳ #62 — feat(web): Добавить прогресс-бар         [web]       P2
  ↳ #63 — refactor(web): Вынести логику в хук      [web]       P3
✓ #64 — perf(api): ...  (обычный issue)            [api]       P2

Для выполнения запусти:
  /issue-executor --label web
  /issue-executor 61 62 63 64
```
